import { Server as SocketIOServer, Socket } from 'socket.io';
import { isDevelopment } from '../config';
import { setupPresentialAudioHandlers } from './audioHandler';
import { setupOnlineConsultationHandlers } from './onlineConsultationHandler';

// Interfaces para eventos WebSocket
interface SessionJoinData {
  sessionId: string;
  userId: string;
  role: 'doctor' | 'patient';
}

interface AudioData {
  sessionId: string;
  chunk: Buffer;
  sampleRate: number;
  channels: number;
  timestamp: number;
}

// Setup dos handlers WebSocket
export function setupWebSocketHandlers(io: SocketIOServer): void {
  const notifier = new SessionNotifier(io);
  io.on('connection', (socket: Socket) => {
    if (isDevelopment) {
      console.log(`WebSocket conectado: ${socket.id}`);
    }

    // Configurar handlers de √°udio presencial
    setupPresentialAudioHandlers(socket, notifier);

    // Configurar handlers de consulta online
    setupOnlineConsultationHandlers(socket, notifier);

    // Handler para participar de uma sess√£o
    socket.on('session:join', (data: SessionJoinData) => {
      const { sessionId, userId, role } = data;
      
      if (!sessionId || !userId || !role) {
        socket.emit('error', {
          code: 'INVALID_SESSION_DATA',
          message: 'Dados de sess√£o inv√°lidos',
        });
        return;
      }

      // Entrar na sala da sess√£o
      socket.join(`session:${sessionId}`);
      
      // Notificar outros participantes
      socket.to(`session:${sessionId}`).emit('participant:joined', {
        userId,
        role,
        timestamp: new Date().toISOString(),
      });

      // Confirmar entrada na sess√£o
      socket.emit('session:joined', {
        sessionId,
        userId,
        role,
        timestamp: new Date().toISOString(),
      });


      if (isDevelopment) {
        console.log(`Usuario ${userId} (${role}) entrou na sess√£o ${sessionId}`);
      }
    });

    // Handler para sair de uma sess√£o
    socket.on('session:leave', (data: { sessionId: string; userId: string }) => {
      const { sessionId, userId } = data;
      
      if (sessionId) {
        socket.leave(`session:${sessionId}`);
        
        // Notificar outros participantes
        socket.to(`session:${sessionId}`).emit('participant:left', {
          userId,
          timestamp: new Date().toISOString(),
        });

        if (isDevelopment) {
          console.log(`Usuario ${userId} saiu da sess√£o ${sessionId}`);
        }
      }
    });

    // Handler para receber dados de √°udio (prepara√ß√£o para futura implementa√ß√£o)
    socket.on('audio:data', (data: AudioData) => {
      // TODO: Implementar processamento de √°udio
      // Por enquanto, apenas log em desenvolvimento
      if (isDevelopment) {
        console.log(`√Åudio recebido da sess√£o ${data.sessionId}: ${data.chunk.length} bytes`);
      }
      
      // Placeholder: repassar para processamento de ASR
      // Ser√° implementado nas pr√≥ximas fases
    });

    // Handler para status de transcri√ß√£o
    socket.on('transcription:request', (data: { sessionId: string }) => {
      const { sessionId } = data;
      
      // TODO: Buscar transcri√ß√µes existentes da sess√£o
      // Por enquanto, retorna vazio
      socket.emit('transcription:update', {
        sessionId,
        utterances: [],
        timestamp: new Date().toISOString(),
      });
    });

    // Handler para marcar sugest√£o como usada
    socket.on('suggestion:used', async (data: { suggestionId: string; sessionId: string; userId?: string }) => {
      const { suggestionId, sessionId, userId = 'unknown' } = data;
      
      try {
        // Importar suggestionService dinamicamente para evitar depend√™ncia circular
        const { suggestionService } = await import('../services/suggestionService');
        
        // Marcar sugest√£o como usada no banco
        const success = await suggestionService.markSuggestionAsUsed(suggestionId, userId);
        
        if (success) {
          // Notificar outros participantes da sess√£o
          notifier.emitSuggestionUsed(sessionId, suggestionId, userId);
          
          if (isDevelopment) {
            console.log(`‚úÖ Sugest√£o ${suggestionId} marcada como usada na sess√£o ${sessionId} por ${userId}`);
          }
        } else {
          socket.emit('error', {
            code: 'SUGGESTION_UPDATE_FAILED',
            message: 'Falha ao marcar sugest√£o como usada'
          });
        }
      } catch (error) {
        console.error('‚ùå Erro ao marcar sugest√£o como usada:', error);
        socket.emit('error', {
          code: 'SUGGESTION_UPDATE_ERROR',
          message: 'Erro interno ao processar sugest√£o'
        });
      }
    });

    // Handler para solicitar sugest√µes existentes
    socket.on('suggestions:request', async (data: { sessionId: string }) => {
      const { sessionId } = data;
      
      try {
        const { suggestionService } = await import('../services/suggestionService');
        const suggestions = await suggestionService.getSessionSuggestions(sessionId);
        
        socket.emit('suggestions:response', {
          sessionId,
          suggestions,
          count: suggestions.length,
          timestamp: new Date().toISOString()
        });
        
        if (isDevelopment) {
          console.log(`üìã ${suggestions.length} sugest√µes enviadas para sess√£o ${sessionId}`);
        }
      } catch (error) {
        console.error('‚ùå Erro ao buscar sugest√µes:', error);
        socket.emit('error', {
          code: 'SUGGESTIONS_FETCH_ERROR',
          message: 'Erro ao buscar sugest√µes da sess√£o'
        });
      }
    });

    // Handler para solicitar gera√ß√£o manual de sugest√µes
    socket.on('suggestions:generate', async (data: { sessionId: string; force?: boolean }) => {
      const { sessionId, force = false } = data;
      
      try {
        const { suggestionService } = await import('../services/suggestionService');
        
        // Buscar contexto da sess√£o
        const { db } = await import('../config/database');
        const session = await db.getSession(sessionId);
        const utterances = await db.getSessionUtterances(sessionId);
        
        if (!session) {
          socket.emit('error', {
            code: 'SESSION_NOT_FOUND',
            message: 'Sess√£o n√£o encontrada'
          });
          return;
        }
        
        const context = {
          sessionId,
          patientName: 'Paciente', // TODO: Buscar nome real
          sessionDuration: Math.floor((Date.now() - new Date(session.created_at).getTime()) / (1000 * 60)),
          consultationType: session.session_type || 'presencial',
          utterances: utterances.slice(-10),
          specialty: 'clinica_geral'
        };
        
        const result = await suggestionService.generateSuggestions(context);
        
        if (result) {
          notifier.emitAISuggestions(sessionId, result.suggestions);
          notifier.emitContextUpdate(sessionId, result.context_analysis);
          
          if (isDevelopment) {
            console.log(`ü§ñ ${result.suggestions.length} sugest√µes geradas manualmente para sess√£o ${sessionId}`);
          }
        }
      } catch (error) {
        console.error('‚ùå Erro ao gerar sugest√µes:', error);
        socket.emit('error', {
          code: 'SUGGESTIONS_GENERATION_ERROR',
          message: 'Erro ao gerar sugest√µes'
        });
      }
    });

    // Handler para erros
    socket.on('error', (error) => {
      console.error(`WebSocket Error [${socket.id}]:`, error);
    });

    // Handler para desconex√£o
    socket.on('disconnect', (reason) => {
      if (isDevelopment) {
        console.log(`WebSocket desconectado: ${socket.id} - ${reason}`);
      }

      // TODO: Cleanup de sess√µes ativas
      // Remover usu√°rio de todas as salas que estava participando
    });

    // Handler para ping/pong (manter conex√£o viva)
    socket.on('ping', () => {
      socket.emit('pong', {
        timestamp: new Date().toISOString(),
      });
    });
  });

  // Configurar middleware de autentica√ß√£o para WebSocket (futuro)
  io.use((socket, next) => {
    // TODO: Implementar autentica√ß√£o de WebSocket
    // Por enquanto, permitir todas as conex√µes
    next();
  });

  // Log de status do WebSocket
  if (isDevelopment) {
    io.engine.on('connection_error', (err) => {
      console.log('WebSocket connection error:', err.req, err.code, err.message, err.context);
    });
  }
}

// Utilit√°rios para emitir eventos para sess√µes espec√≠ficas
export class SessionNotifier {
  constructor(private io: SocketIOServer) {}

  // Notificar nova transcri√ß√£o para uma sess√£o
  emitTranscriptionUpdate(sessionId: string, utterance: any) {
    this.io.to(`session:${sessionId}`).emit('transcription:update', {
      sessionId,
      utterance,
      timestamp: new Date().toISOString(),
    });
  }

  // Notificar nova sugest√£o de IA para uma sess√£o
  emitAISuggestion(sessionId: string, suggestion: any) {
    this.io.to(`session:${sessionId}`).emit('ai:suggestion', {
      sessionId,
      suggestion,
      timestamp: new Date().toISOString(),
    });
  }

  // Notificar m√∫ltiplas sugest√µes de IA para uma sess√£o
  emitAISuggestions(sessionId: string, suggestions: any[]) {
    this.io.to(`session:${sessionId}`).emit('ai:suggestions', {
      sessionId,
      suggestions,
      count: suggestions.length,
      timestamp: new Date().toISOString(),
    });
  }

  // Notificar atualiza√ß√£o de contexto da IA
  emitContextUpdate(sessionId: string, context: any) {
    this.io.to(`session:${sessionId}`).emit('ai:context_update', {
      sessionId,
      context,
      timestamp: new Date().toISOString(),
    });
  }

  // Notificar que uma sugest√£o foi marcada como usada
  emitSuggestionUsed(sessionId: string, suggestionId: string, userId: string) {
    this.io.to(`session:${sessionId}`).emit('ai:suggestion:used', {
      sessionId,
      suggestionId,
      userId,
      timestamp: new Date().toISOString(),
    });
  }

  // Notificar status de processamento
  emitProcessingStatus(sessionId: string, status: 'processing' | 'completed' | 'error', message?: string) {
    this.io.to(`session:${sessionId}`).emit('processing:status', {
      sessionId,
      status,
      message,
      timestamp: new Date().toISOString(),
    });
  }

  // Notificar erro espec√≠fico de sess√£o
  emitSessionError(sessionId: string, error: { code: string; message: string }) {
    this.io.to(`session:${sessionId}`).emit('session:error', {
      sessionId,
      error,
      timestamp: new Date().toISOString(),
    });
  }

  // Notificar atividade de voz
  emitVoiceActivity(sessionId: string, channel: string, isActive: boolean) {
    this.io.to(`session:${sessionId}`).emit('presential:voice_activity', {
      sessionId,
      channel,
      isActive,
      timestamp: new Date().toISOString()
    });
  }
}